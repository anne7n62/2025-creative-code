<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      img {
        max-width: 100vw;
        max-height: 100vh;
      }

      .settingsWrapper {
        width: 300px;
        position: absolute;
        top: 10;
        right: 10;
        z-index: 2;
      }

     

      .slider {
  -webkit-appearance: none;
  width: 100%;
  height: 25px;
  background: #d3d3d3;
  outline: none;
  opacity: 0.7;
  -webkit-transition: .2s;
  transition: opacity .2s;
}

.slider:hover {
  opacity: 1;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 25px;
  height: 25px;
  background: #04AA6D;
  cursor: pointer;
}

.slider::-moz-range-thumb {
  width: 25px;
  height: 25px;
  background: #04AA6D;
  cursor: pointer;
}
    </style>
  </head>
  <body>
   <section id="settingsWrapper">
    <input type="range" min="5" max="30" value="20" class="slider" id="brushSizeSlider">
    <input type="range" min="5" max="30" value="10" class="slider" id="pixelBlockSlider">
   </section>
       
</div>
    <canvas id="canvas"> 
     
    </canvas>

    <script>
  

      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      const img = new Image();
      img.src = "img.jpg"; // ⚠️ replace with your image

      const brushSize = 80; // how big each scrambled area is
      const pixelBlock = 25; // how "chunky" each block becomes

      img.onload = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const canvasRatio = canvas.width / canvas.height;
        const imgRatio = img.width / img.height;

        let drawWidth, drawHeight, offsetX, offsetY;

        if (canvasRatio > imgRatio) {
          // canvas is wider -> stretch image height to match
          drawWidth = canvas.width;
          drawHeight = canvas.width / imgRatio;
          offsetX = 0;
          offsetY = (canvas.height - drawHeight) / 2;
        } else {
          // canvas is taller -> stretch image width to match
          drawHeight = canvas.height;
          drawWidth = canvas.height * imgRatio;
          offsetY = 0;
          offsetX = (canvas.width - drawWidth) / 2;
        }

        ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
      };

      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        //grabbing raw pixel data (RGBA values) from a rectangular area under your brush.
        const imgData = ctx.getImageData(x, y, brushSize, brushSize);
        const data = imgData.data;

        // Pixelate the patch.
        //         → We move through the pixel area in jumps of pixelBlock.
        // So if pixelBlock = 6, we’re sampling every 6 pixels horizontally and vertically.
        // This skips detail — that’s what creates the blocky “pixelation.”
        for (let py = 0; py < brushSize; py += pixelBlock) {
          for (let px = 0; px < brushSize; px += pixelBlock) {
            const i = (py * brushSize + px) * 4;
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillRect(x + px, y + py, pixelBlock, pixelBlock);
          }
        }
      });
    </script>
  </body>
</html>
